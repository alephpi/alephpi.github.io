import{_ as a,c as l,g as e,o as n}from"./chunks/framework.n-91xA-b.js";const u=JSON.parse('{"title":"三二七","description":"","frontmatter":{"title":"三二七","date":"2024-10-29T20:26:27.644Z","length":"661字","time":"3分钟","aside":false,"hash":546300609},"headers":[],"relativePath":"idea/327.md","filePath":"idea/327.md"}'),s={name:"idea/327.md"};function r(o,t,d,i,p,c){return n(),l("div",null,t[0]||(t[0]=[e("p",null,"在学扩散模型的过程中受扩散模型启发的学习方法论。制作因果链条有两种方式：一种是一环套一环的，每一环都必须保证绝对严密无可动摇，再套上下一环；另一种是先搭出因果链的骨架，然后一点点修补上面的裂隙。前者是自回归模型（脑子每刻都储存着当前推理的状态，然后根据当前推理的结果计算下一步推论），后者是扩散模型（脑子迅速把握一条丐版推理链，然后一点点消除其中的问题逼近最终的合理路径）。",-1),e("p",null,"自回归模型是天然的，对应着线性思维（线性时间观）。但是当每一步跨越都极为艰难时，从理论到实践就过于漫长，它甚至没有办法在有限的时间内给出一个解决方案，或者说只有当它完成了那一目标，过去的步骤才能被回溯性认定为有益，正如闪电追认了云层中富集的电荷的运动。（自回归的代价非常大，因为它一旦迈出一步就不可更改，于是背负了沉重的历史包袱，有时不得不硬着头皮走下去，去逼迫一个结果。）而扩散模型，在有限的时间内起码能给出一个结果，然后慢慢修正它（回溯性的时间观）。",-1),e("p",null,"这绝不是说扩散和自回归是对立的，相反在构造那条丐版因果链时本身就是在做自回归，但唯一的区别在于它是可以动摇的，或者说在推理过程中，在理论到实践的路上，我们允许留下这样或那样的坑坑洼洼，留到日后处理，毕竟抵达终点比修路更重要。说穿了这是先磨刀还是先砍柴的抉择。尽管我们说磨刀不误砍柴工，可如果樵夫还没进山就在家磨刀，走到山里发现到处是俯仰可拾的碎柴，岂不尴尬。",-1),e("p",null,"说白了，如果上来就想走最好的路，那多半发现自己无路可走。先莽出一条路，然后再研究怎么改进它，也就是说把力气均等的分摊在整条路径上，而不是想破脑袋只顾下一步怎么走，因为很有可能当你走到终点后发现那一步的踌躇无关紧要。",-1),e("p",null,"学习如此、写文章如此、写代码如此、生活亦如此。",-1)]))}const _=a(s,[["render",r]]);export{u as __pageData,_ as default};
