import{_ as p,c as t,ao as a,o}from"./chunks/framework.n-91xA-b.js";const f=JSON.parse('{"title":"三二六","description":"","frontmatter":{"title":"三二六","date":"2024-10-27T11:12:51.441Z","length":"1140字","time":"4分钟","aside":false,"hash":1147494730},"headers":[],"relativePath":"idea/326.md","filePath":"idea/326.md"}'),n={name:"idea/326.md"};function r(s,e,i,_,d,c){return o(),t("div",null,e[0]||(e[0]=[a("<p>难怪说命名是最困难的事，它就是注册进符号界的第一步，万事开头难。也难怪说名不正言不顺，没有名称，我们只能间接的指称它，而那间接的称谓势必挪用了原本指代另一个事物的名称，从而造成意义的混淆。</p><p>起名不能过于宽泛，会让人搞不懂到底它指的是本身，还是囊括它的那个更大的集合。说白了，就是“是”的两种含义，你说 A 是 S，它既可以有“A=S”的含义，又可以有“A∈S”的含义。既然是取名，就要排除掉后者的歧义。如果 S 这个名称在概念上不够专题化，就可能会造成后者的歧义。</p><p>最近在研究字体。有一种东西叫做连字，就是连续若干个字符的特定组合不同于它们字形简单的呈现形式，比如 fi 的连字，f 的弯头会与 i 的点粘合。那么“连字”应该是字体的“特性”，即“连字”属于“特性”。可“特性”这个词在我的先验认识中是一种比较粗的概念，比如解释性是 python 的一种特性，除此之外还有许多特性，比如 list comprehension 等等。结果在字体设计领域有种字体格式叫 OpenType，而“OpenType 特性”就是指那种定义了连字的映射表，害我之前总是在想这种特性（“属于”）到底叫什么名字，没想到它就叫“特性”（“等于”）。</p><p>这就好像一个人的名字叫“人”一样，我知道你是人不是什么别的动物，但你作为人和动物的差异并不能足以让我把握你。你是不是应该取个更特别的名字，而不是玷污了稀缺的通用命名空间。</p><p>即便这种特性是唯一的，那还是那个老问题，就是当一个集合中只有一个元素的时候，你不能把集合名和元素名本身混淆起来吧。</p><p>糟糕的事还不止于此。那种可以生成映射表的脚本语言还没有名字，人们只能用可以编译这种语言的工具（afdko）来称呼它，就好比 python 不叫 python，你管他叫 python interpreter 一样。这真是倒反天罡了，因为你在用函数称呼值，用映射称呼被映射物，用动作称呼受动（说起来吴语就是这样，用“屙”来称呼“屎”，全国独一“粪”了）</p><p>甚至还有用“特性语言”、“特性格式”来称呼那个脚本，结果前面关于“特性”的混乱又多掺和进一个脚本了。霎时间我的脑子里充斥着一堆张三，我知道他们不是同一个人，但我又不知道究竟谁是谁。</p><p>直到现在，当我真正在能指拓扑中分开他们的时候，这篇吐槽本身才成为可能。</p><p>以前学代数的时候感觉全在学概念，变成名词党了。然而在复杂的现代，你真的需要先变成一个名词党，给你的命名空间创造足够的冗余来辨别出不同的概念，否则你的脑子会变得光滑而匀质，根本无法触摸到能指网络的细微纹理。连名词党都做不到，就比名词党更值得吐槽。</p><p>反对名词党不是要去能指化，而是要让能指注入能指网络，让它真正的流动起来，名词党是手段而不是目的，但失去手段是万万不可能的。除非你只关心能指网络的一个局部，限制在那个局部，你的词汇簿堪堪够用了。可是你必须明确的意识到，并不是所有人的词汇簿都对应着同一个局部，你必须掌握一套词汇簿的词汇簿。同时，只有词汇簿更细的人才能兼容词汇簿粗的人。也许你已经发现了，在这里我们谈论的 vocabulary 就是 atlas。</p><p>如果失去差异，能指链就停滞了，人作为符号动物就搁浅在历史的沙滩上了（顽固不化，注意区分顽固与坚持，顽固是对差异化的拒斥，而坚持是对差异化的坚持，二者恰恰相反）。而命名就是为了差异化，是差异化运动的第一步。这就是差异辩证法。</p>",11)]))}const m=p(n,[["render",r]]);export{f as __pageData,m as default};
