import{_ as e,c as o,ap as i,o as l}from"./chunks/framework.CCxIPCIe.js";const h=JSON.parse('{"title":"不同语言的混合项目","description":"","frontmatter":{"title":"不同语言的混合项目","date":"2025-12-23T19:18:51.393Z","length":"555字","time":"2分钟","aside":true,"hash":-932629329},"headers":[],"relativePath":"note/编程/不同语言的混合项目.md","filePath":"note/编程/不同语言的混合项目.md"}'),p={name:"note/编程/不同语言的混合项目.md"};function n(a,t,r,_,s,c){return l(),o("div",null,t[0]||(t[0]=[i('<p>参考视频：</p><ol><li><a href="https://www.bilibili.com/video/BV1aXbXzfEsM" target="_blank" rel="noreferrer">https://www.bilibili.com/video/BV1aXbXzfEsM</a></li><li><a href="https://www.bilibili.com/video/BV12hm9BmELJ" target="_blank" rel="noreferrer">https://www.bilibili.com/video/BV12hm9BmELJ</a></li></ol><p>在逛 github 的时候，时常能发现一些复杂的工程仓库包含多种不同类型的编程语言，那么这些语言是如何协同工作的呢？</p><ol><li><p>第一种最简单的情况就是前后端分离的应用，不同语言编写的程序在前后端进程中分别执行，并通过网络接口通信。例如前端三件套+python 后端。</p></li><li><p>第二种情况是不同编译型语言混合的应用。编译型语言在从脚本转换到机器码之间会经历几个步骤：预处理、编译、汇编、连接。那么不同编译型语言的转换过程会经历相似的过程，因而可以在获得相同输出的步骤插入。例如 FFmpeg 同时使用了 C 和 汇编语言，那么汇编语言部分就可以插入 C 编译后的<code>.s</code>文件，然后一同汇编得到 <code>.o</code> 文件。再比如 Rust 可以编译成<code>.so</code>动态库然后被链接到<code>.o</code>文件，那么在执行时会被加载到同一进程的内存中，从而实现协作。</p></li><li><p>第三种情况是编译型语言和解释型语言混合的应用。这又分为两种情况：</p><ol><li>在解释型语言中调用编译型语言的外部动态库。例如 python 中的 numpy 库底层许多函数使用 C++ 实现，本质上就是把这些 C++ 实现的动态库暴露出一个 python 接口，使得 python 解释器（C 程序）可以以 python 函数的形式调用之（另一个 C 程序）。</li><li>在编译型语言中操纵解释型语言。例如在 C 中操纵 python，它本质上是在 C 中获取了 python 解释器（C 程序）暴露的公共接口，并调用之，因此该程序可以获取解释型语言中的变量、函数等等。python 解释器本质上是一个 C 程序，而 python 程序是作为这个程序的数据被读入的。那么实际上这种调用关系是：C 程序-&gt;python 解释器-&gt;python 脚本。</li></ol></li></ol>',4)]))}const m=e(p,[["render",n]]);export{h as __pageData,m as default};
