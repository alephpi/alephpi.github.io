import{_ as a,c as o,ao as n,o as l}from"./chunks/framework.n-91xA-b.js";const f=JSON.parse('{"title":"关于 notebook autoreload 的一个小坑","description":"","frontmatter":{"title":"关于 notebook autoreload 的一个小坑","date":"2025-08-12T15:45:06.407Z","length":"331字","time":"2分钟","aside":true,"hash":1542420596},"headers":[],"relativePath":"note/编程/关于notebook autoreload的一个小坑.md","filePath":"note/编程/关于notebook autoreload的一个小坑.md"}'),e={name:"note/编程/关于notebook autoreload的一个小坑.md"};function p(t,s,c,r,i,d){return l(),o("div",null,s[0]||(s[0]=[n(`<p>在 python 开发时，我比较喜欢的做法是在<code>.py</code>文件中写函数，然后开一个相应的<code>test.ipynb</code> notebook 调试。例如：</p><div class="language-py"><button title="Copy Code" class="copy"></button><span class="lang">py</span><pre class="shiki solarized-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#586E75;font-style:italic;"># foo.py</span></span>
<span class="line"><span style="color:#93A1A1;font-weight:bold;">def</span><span style="color:#268BD2;"> foo</span><span style="color:#839496;">():</span></span>
<span class="line"><span style="color:#839496;">    msg </span><span style="color:#859900;">=</span><span style="color:#2AA198;"> &#39;Hi&#39;</span></span>
<span class="line"><span style="color:#586E75;font-style:italic;">    # msg = &#39;Hello&#39;</span></span>
<span class="line"><span style="color:#859900;">    return</span><span style="color:#839496;"> msg</span></span></code></pre></div><div class="language-py"><button title="Copy Code" class="copy"></button><span class="lang">py</span><pre class="shiki solarized-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#586E75;font-style:italic;"># test.ipynb</span></span>
<span class="line"><span style="color:#586E75;font-style:italic;"># cell1</span></span>
<span class="line"><span style="color:#859900;">%</span><span style="color:#839496;">load_ext autoreload</span></span>
<span class="line"><span style="color:#859900;">%</span><span style="color:#839496;">autoreload </span><span style="color:#D33682;">2</span></span>
<span class="line"><span style="color:#586E75;font-style:italic;"># cell2</span></span>
<span class="line"><span style="color:#859900;">from</span><span style="color:#839496;"> foo </span><span style="color:#859900;">import</span><span style="color:#839496;"> foo</span></span>
<span class="line"><span style="color:#586E75;font-style:italic;"># cell3</span></span>
<span class="line"><span style="color:#839496;">foo()</span></span></code></pre></div><p>这样一旦根据 notebook 中的调试结果在 <code>foo.py</code> 对函数进行改动，就可以实时反馈继续调试。</p><p>不过这个 autoreload 的功能仅仅局限于追踪类和函数的改动，比如以下逻辑：</p><div class="language-py"><button title="Copy Code" class="copy"></button><span class="lang">py</span><pre class="shiki solarized-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#586E75;font-style:italic;"># foo.py</span></span>
<span class="line"><span style="color:#839496;">foo </span><span style="color:#859900;">=</span><span style="color:#2AA198;"> &#39;Hi&#39;</span></span>
<span class="line"><span style="color:#586E75;font-style:italic;"># foo = &#39;Hello&#39;</span></span></code></pre></div><p>这种情况下，切换两行注释后，如果仅仅运行 <code>cell3</code> 并不能改变在 notebook 中导入的 foo 值。如果运行 <code>cell2</code> 重新导入 <code>foo</code>，就可以更新了。</p><p>但更隐蔽的坑在于如果简单的调整一下上述逻辑，把它变成</p><div class="language-py"><button title="Copy Code" class="copy"></button><span class="lang">py</span><pre class="shiki solarized-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#586E75;font-style:italic;"># foo.py</span></span>
<span class="line"><span style="color:#859900;">from</span><span style="color:#839496;"> bar </span><span style="color:#859900;">import</span><span style="color:#839496;"> bar</span></span>
<span class="line"><span style="color:#839496;">foo </span><span style="color:#859900;">=</span><span style="color:#839496;"> bar()</span></span></code></pre></div><div class="language-py"><button title="Copy Code" class="copy"></button><span class="lang">py</span><pre class="shiki solarized-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#586E75;font-style:italic;"># bar.py</span></span>
<span class="line"><span style="color:#93A1A1;font-weight:bold;">def</span><span style="color:#268BD2;"> bar</span><span style="color:#839496;">():</span></span>
<span class="line"><span style="color:#839496;">    msg </span><span style="color:#859900;">=</span><span style="color:#2AA198;"> &#39;Hi&#39;</span></span>
<span class="line"><span style="color:#586E75;font-style:italic;">    # msg = &#39;Hello&#39;</span></span>
<span class="line"><span style="color:#859900;">    return</span><span style="color:#839496;"> msg</span></span></code></pre></div><p>此时如果在<code>bar.py</code>中切换两行注释，即便重新运行 <code>cell2</code> 重新导入<code>foo</code>，也不会改变 <code>foo</code> 的值。</p><p>是不是有点意外？我今天写的代码就掉进了这个坑。目前我觉得规避这个问题的方法是在使用 autoreload 的特性时不要引入一个变量，总是先引入函数再赋值就可以确保函数是更新的。</p>`,12)]))}const b=a(e,[["render",p]]);export{f as __pageData,b as default};
