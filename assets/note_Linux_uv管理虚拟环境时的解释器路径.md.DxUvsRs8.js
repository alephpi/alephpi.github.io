import{_ as o,c as t,ap as n,o as a}from"./chunks/framework.CCxIPCIe.js";const u=JSON.parse('{"title":"uv 管理虚拟环境时的解释器路径","description":"","frontmatter":{"title":"uv 管理虚拟环境时的解释器路径","date":"2025-11-19T12:23:30.060Z","length":"316字","time":"2分钟","aside":true,"hash":1916191728},"headers":[],"relativePath":"note/Linux/uv管理虚拟环境时的解释器路径.md","filePath":"note/Linux/uv管理虚拟环境时的解释器路径.md"}'),c={name:"note/Linux/uv管理虚拟环境时的解释器路径.md"};function s(p,e,d,_,l,r){return a(),t("div",null,e[0]||(e[0]=[n('<p>昨天重新跑了一次两个月前的实验脚本，莫名其妙报错了。什么都没有修改过，路径是正确的，虚拟环境也是正确的，但就是提示某个 module 找不到。</p><p>今天早上和服务器的管理员反馈了一下，原来是服务器的系统升级了，python 默认解释器也更新了。起先我用<code>uv venv -python 3.10</code>创建虚拟环境时，由于彼时的服务器默认 python 解释器是 3.10，于是就把虚拟环境中的 python 链接到了<code>usr/bin/python</code>，然而这个目录对于不同的服务器对应的是不同的解释器，因而在更换服务器或系统升级后会造成不一致性。</p><p>因此，最妥善的办法是把解释器总是安装到<code>~</code>目录下，即由<code>uv</code>托管的目录，默认为<code>~/.local/share/uv/python/</code>，这样哪怕服务器升级，以同一身份登录时，也总是访问固定的目录，从而避免了这种冲突。为此应当使用在<code>uv init</code>或<code>uv venv</code>后加上<code>--managed-python</code>以避免使用系统 python。或者在<code>~/.config/uv/uv.toml</code>中写明</p><div class="language-toml"><button title="Copy Code" class="copy"></button><span class="lang">toml</span><pre class="shiki solarized-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#268BD2;">python-preference</span><span style="color:#839496;"> = </span><span style="color:#2AA198;">&quot;managed&quot;</span></span></code></pre></div><p>以一劳永逸的解决这个问题。</p>',5)]))}const v=o(c,[["render",s]]);export{u as __pageData,v as default};
