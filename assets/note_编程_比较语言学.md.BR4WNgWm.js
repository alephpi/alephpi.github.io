import{_ as e,c as t,ao as a,o as n}from"./chunks/framework.n-91xA-b.js";const l="/assets/python-logo-only.drVeymp-.svg",c=JSON.parse('{"title":"比较语言学","description":"","frontmatter":{"title":"比较语言学","date":"2023-08-08T09:59:04.779Z","length":"714字","time":"3分钟","aside":true,"hash":1170702746},"headers":[],"relativePath":"note/编程/比较语言学.md","filePath":"note/编程/比较语言学.md"}'),p={name:"note/编程/比较语言学.md"};function s(i,o,r,h,d,_){return n(),t("div",null,o[0]||(o[0]=[a('<blockquote><p>注意，本文不是通常意义上的比较语言学</p></blockquote><h2 id="python-vs-js" tabindex="-1">python vs js <a class="header-anchor" href="#python-vs-js" aria-label="Permalink to &quot;python vs js&quot;">​</a></h2><p>python几乎可以算作我的第一母语了。尽管在学它之前还接触过VB、C、Java，奈何那些都是迫不得已，而且也浅尝辄止。喜欢Python主要因为它的语法最简洁干净。说到语法，lisp的语法也给我留下了深刻印象，我想任何学数学的朋友都难以抗拒那种统一的魅力。话说回来，头一次看到js和ts的logo时候，我的脑子里就浮现出下面这张图片：</p><p><img src="'+l+'" alt="" loading="lazy"></p><p>是不是很妙？细细想来，python和js命运十分相似：</p><ol><li>二者起初都被设计为脚本式的轻量语言：python旨在培养人们代码缩进的习惯，长期以来只是bash的一个替代品。而js只是浏览器中帮助渲染网页的脚本，且只能在浏览器中工作。</li><li>二者都随着时代变迁被拔高，甚至被赋予了超出其设计的使命：数据科学乃至人工智能的兴起激发了python生态的爆炸，web技术的兴起乃至前后端打通趋势激发了js生态的爆炸。</li><li>由于承担着这种使命，二者身上都应验了这句话：任何能用X写的算法，最终都会用X写。</li></ol><h3 id="包管理工具" tabindex="-1">包管理工具 <a class="header-anchor" href="#包管理工具" aria-label="Permalink to &quot;包管理工具&quot;">​</a></h3><p>包管理的主要矛盾是，一般来说同一个环境中只能存在一个版本的软件包。但是在开发过程中，不同项目的依赖版本不同，使用同一个环境不仅混乱，甚至会造成冲突。</p><p>python:</p><ul><li>pip: python自带的包管理工具，同时采用虚拟环境env管理依赖，每个环境提供独立的python解释器和相关包，不同的工程使用特定环境下的解释器访问特定包。</li><li>conda: 用python编写的第三方包管理工具，同样采用虚拟环境，它的特点是可以管理非python包的依赖。</li><li>mamba: 用C++重写的conda，更快。</li></ul><p>js:</p><ul><li>npm: js没有“自带的”包管理器。js生态兴起以后，node和npm深度绑定，双方互利共赢。npm的包管理方式比较简单粗暴，在每个项目文件夹下建立一个node_modules文件夹，并将所有依赖安装于此。在开发与打包发布时，搜索最近的node_modules。</li><li>yarn: 没用过不熟hh。</li><li>pnpm: npm的简洁版。所有安装包固定下载到一个全局node_modules文件夹。在每个项目下的node_modules文件夹中的依赖则是到全局node_modules中包的符号链接。</li></ul><h3 id="杂" tabindex="-1">杂 <a class="header-anchor" href="#杂" aria-label="Permalink to &quot;杂&quot;">​</a></h3><p>python 的 @property 类似于 vue 的 computed property，二者都是一种getter-setter结构，而且都是依赖更新后才会求值，否则使用缓存。</p>',14)]))}const u=e(p,[["render",s]]);export{c as __pageData,u as default};
